<html>
<head>
	<title>Syntax Diagram Editor</title>
 	<link rel="stylesheet" href="css/wordpress.css" type="text/css" media="screen" />
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<style type="text/css" media="screen">
		#page { background: url("images/draw/drawbg.jpg") repeat-y top; border: none; }
	</style>
	<script type="text/javascript">
		var mxBasePath = '../../src';
	</script>
	<script type="text/javascript" src="../../src/js/mxClient.js"></script>
	<script type="text/javascript" src="js/app.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/canvg/dist/browser/canvg.min.js"></script>
	<script type="text/javascript">
		// Program starts here. The document.onLoad executes the
		// createEditor function with a given configuration.
		// In the config file, the mxEditor.onInit method is
		// overridden to invoke this global function as the
		// last step in the editor constructor.
		function onInit(editor)
		{

			// Enables guides
			mxGraphHandler.prototype.guidesEnabled = true;

		    // Alt disables guides
		    mxGuide.prototype.isEnabledForEvent = function(evt)
		    {
		    	return !mxEvent.isAltDown(evt);
		    };

			// Enables snapping waypoints to terminals
			mxEdgeHandler.prototype.snapToTerminals = true;

			// Defines an icon for creating new connections in the connection handler.
			// This will automatically disable the highlighting of the source vertex.
			mxConnectionHandler.prototype.connectImage = new mxImage('images/connector.gif', 16, 16);

			// Enables connections in the graph and disables
			// reset of zoom and translate on root change
			// (ie. switch between XML and graphical mode).
			editor.graph.setConnectable(false);

			// Clones the source if new connection has no target
			editor.graph.connectionHandler.setCreateTarget(true);

			// Title
			//var title = document.getElementById('title');
			//title.innerHTML = 'Syntax Diagram Editor'

		    // Changes the zoom on mouseWheel events
		    mxEvent.addMouseWheelListener(function (evt, up)
		    {
			    if (!mxEvent.isConsumed(evt))
			    {
			    	if (up)
					{
			    		editor.execute('zoomIn');
					}
					else
					{
						editor.execute('zoomOut');
					}

					mxEvent.consume(evt);
			    }
		    });

			// Defines a new action to switch between
			// XML and graphical display
			var textNode = document.getElementById('xml');
			var graphNode = editor.graph.container;
			var sourceInput = document.getElementById('source');
			sourceInput.checked = false;

			var funct = function(editor)
			{
				if (sourceInput.checked)
				{
					graphNode.style.display = 'none';
					textNode.style.display = 'inline';

					var enc = new mxCodec();
					var node = enc.encode(editor.graph.getModel());

					textNode.value = mxUtils.getPrettyXml(node);
					textNode.originalValue = textNode.value;
					textNode.focus();
				}
				else
				{
					graphNode.style.display = '';

					if (textNode.value != textNode.originalValue)
					{
						var doc = mxUtils.parseXml(textNode.value);
						var dec = new mxCodec(doc);
						dec.decode(doc.documentElement, editor.graph.getModel());
					}

					textNode.originalValue = null;

					// Makes sure nothing is selected in IE
					if (mxClient.IS_IE)
					{
						mxUtils.clearSelection();
					}

					textNode.style.display = 'none';
					editor.execute('actualSize');
					// Moves the focus back to the graph
					editor.graph.container.focus();
				}
			};

			editor.addAction('switchView', funct);

			// Defines a new action to switch between
			// XML and graphical display
			mxEvent.addListener(sourceInput, 'click', function()
			{
				editor.execute('switchView');
			});

			// draw/hide Overlays

			var overlayInput = document.getElementById('overlayToggle');
			overlayInput.checked = true;

			var toggleOverlay = function(editor)
			{
				if (overlayInput.checked)
				{
					var parent = editor.graph.getDefaultParent();
					var containerList = editor.graph.getChildCells(parent);
					if (containerList.length > 0) {
						// going through containers
						for (var i = 0; i < containerList.length; i++) {
							// going through edges inside container
							var childCells = editor.graph.getChildEdges(containerList[i])
							for (var z = 0; z < childCells.length; z++) {
									if (editor.graph.getCellOverlays(childCells[z]) != null)
									{
										var cOverlay = editor.graph.getCellOverlays(childCells[z])[0];
										cOverlay.image = new mxImage('images/add.png', 28, 28);
									}
									var cellType = childCells[z].getValue();
									if (cellType.tagName == 'Connector')
									{
											var childEdges = editor.graph.getChildEdges(childCells[z]);
											for (var j = 0; j < childEdges.length; j++)
											{
												if (editor.graph.getCellOverlays(childEdges[j]) != null)
												{
													var cOverlay = editor.graph.getCellOverlays(childEdges[j])[0];
													cOverlay.image = new mxImage('images/add.png', 28, 28);
												}
											}
									}
							}
							// getting the big vertical overlays
							var childCells = containerList[i].children;
							for (var z = 0; z < childCells.length; z++) {
								var cellStyle = childCells[z].style
								if (cellStyle == 'image;image=images/add.png;editable=0;movable=0;selectable=0;resizable=0') {
									childCells[z].visible = true;
								}
							}
						}
					}
				editor.graph.refresh();
				} else {
					var parent = editor.graph.getDefaultParent();
					var cellList = editor.graph.model.getChildCount(parent);
					if (cellList > 0) {
						// going through containers
						var containerList = editor.graph.getChildCells(parent);
						for (var i = 0; i < cellList; i++) {
							// going through object inside container
							var childCells = editor.graph.getChildEdges(containerList[i])
							for (var z = 0; z < childCells.length; z++)
							{
								if (editor.graph.getCellOverlays(childCells[z]) != null)
								{
									var cOverlay = editor.graph.getCellOverlays(childCells[z])[0];
									cOverlay.image = new mxImage('images/add.png', 0, 0);
								}
								var cellType = childCells[z].getValue();
								if (cellType.tagName == 'Connector')
								{
										var childEdges = editor.graph.getChildEdges(childCells[z]);
										for (var j = 0; j < childEdges.length; j++)
										{
											if (editor.graph.getCellOverlays(childEdges[j]) != null)
											{
												var cOverlay = editor.graph.getCellOverlays(childEdges[j])[0];
												cOverlay.image = new mxImage('images/add.png', 0, 0);
											}
										}
								}
							}
							// getting the big vertical overlays
							var childCells = containerList[i].children;
							for (var z = 0; z < childCells.length; z++) {
								var cellStyle = childCells[z].style
								if (cellStyle == 'image;image=images/add.png;editable=0;movable=0;selectable=0;resizable=0') {
									childCells[z].visible = false;
								}
							}
						}
					}
				editor.graph.refresh();
			}};

			editor.addAction('toggleOverlay', toggleOverlay);

			// Defines a new action to switch between
			// XML and graphical display
			mxEvent.addListener(overlayInput, 'click', function()
			{
				editor.execute('toggleOverlay');
			});

			// Create select actions in page
			var node = document.getElementById('mainActions');
			var buttons = ['cut', 'copy', 'paste', 'delete', 'undo', 'redo', 'print', 'show', 'save'];

			// Only adds image and SVG export if backend is available
			// NOTE: The old image export in mxEditor is not used, the urlImage is used for the new export.
			if (editor.urlImage == null)
			{
				// Client-side code for image export
				var exportImage = function(editor)
				{
					overlayInput.checked = false;
					toggleOverlay(editor);
					var graph = editor.graph;
					var scale = graph.view.scale;
					var bounds = graph.getGraphBounds();

		        	// New image export
					var xmlDoc = mxUtils.createXmlDocument();
					var root = xmlDoc.createElement('output');
					xmlDoc.appendChild(root);

				    // Renders graph. Offset will be multiplied with state's scale when painting state.
					var xmlCanvas = new mxXmlCanvas2D(root);
					xmlCanvas.translate(Math.floor(1 / scale - bounds.x), Math.floor(1 / scale - bounds.y));
					xmlCanvas.scale(scale);

					var imgExport = new mxImageExport();
				    imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);

					// Puts request data together
					var w = Math.ceil(bounds.width * scale + 2);
					var h = Math.ceil(bounds.height * scale + 2);
					var xml = mxUtils.getXml(root);

					// Requests image if request is valid
					if (w > 0 && h > 0)
					{
						var name = 'export.png';
						var format = 'png';
						var bg = '&bg=#FFFFFF';

						var documentGraph = mxUtils.show(editor.graph, 'new', 10, 10);
						var svg1 = new XMLSerializer().serializeToString(documentGraph);
						var SVGCode = svg1.substring(
    					svg1.indexOf("<svg"),
					    svg1.indexOf("</svg>")+6
						);
						var canvas = document.createElement('canvas');
						canvg(canvas, SVGCode, {userCORS: true});
						var dataURL = canvas.toDataURL('image/png');
						var data = atob(dataURL.substring('data:image/png;base64,'.length)),
        			asArray = new Uint8Array(data.length);
						for (var i = 0, len = data.length; i < len; ++i) {
	    					asArray[i] = data.charCodeAt(i);
						}
						var pngBlob = new Blob([asArray.buffer], {type: 'image/png'});
						var pngUrl = URL.createObjectURL(pngBlob);
						var downloadLink = document.createElement("a");
						downloadLink.href = pngUrl;
						do {
							var fileName = prompt("PNG File Name", "enter here");
							if (fileName.indexOf('.png') == -1) {
								fileName = fileName + '.png';
							}
						} while (fileName.length > 255 || fileName.length <= 0);
						downloadLink.download = fileName;
						document.body.appendChild(downloadLink);
						downloadLink.click();
						document.body.removeChild(downloadLink);
						overlayInput.checked = true;
						toggleOverlay(editor);

						// new mxXmlRequest(editor.urlImage, 'filename=' + name + '&format=' + format +
		        // 			bg + '&w=' + w + '&h=' + h + '&xml=' + encodeURIComponent(xml)).
		        // 			simulate(document, '_blank');
					}
				};

				editor.addAction('exportImage', exportImage);

				// Client-side code for SVG export
				var exportSvg = function(editor)
				{
					overlayInput.checked = false;
					toggleOverlay(editor);
					var graph = editor.graph;
					var scale = graph.view.scale;
					var bounds = graph.getGraphBounds();

				    // Prepares SVG document that holds the output
				    var svgDoc = mxUtils.createXmlDocument();
				    var root = (svgDoc.createElementNS != null) ?
				    	svgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');

					if (root.style != null)
					{
						root.style.backgroundColor = '#FFFFFF';
					}
					else
					{
						root.setAttribute('style', 'background-color:#FFFFFF');
					}

				    if (svgDoc.createElementNS == null)
				    {
				    	root.setAttribute('xmlns', mxConstants.NS_SVG);
				    }

				    root.setAttribute('width', Math.ceil(bounds.width * scale + 2) + 'px');
				    root.setAttribute('height', Math.ceil(bounds.height * scale + 2) + 'px');
				    root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);
				    root.setAttribute('version', '1.1');

				    // Adds group for anti-aliasing via transform
				    var group = (svgDoc.createElementNS != null) ?
					    	svgDoc.createElementNS(mxConstants.NS_SVG, 'g') : svgDoc.createElement('g');
					group.setAttribute('transform', 'translate(0.5,0.5)');
					root.appendChild(group);
				    svgDoc.appendChild(root);

				    // Renders graph. Offset will be multiplied with state's scale when painting state.
				    var svgCanvas = new mxSvgCanvas2D(group);
				    svgCanvas.translate(Math.floor(1 / scale - bounds.x), Math.floor(1 / scale - bounds.y));
				    svgCanvas.scale(scale);

				    var imgExport = new mxImageExport();
				    imgExport.drawState(graph.getView().getState(graph.model.root), svgCanvas);

						var documentGraph = mxUtils.show(editor.graph, 'new', 10, 10);
						var svg1 = new XMLSerializer().serializeToString(documentGraph);
						var SVGCode = svg1.substring(
    					svg1.indexOf("<svg"),
					    svg1.indexOf("</svg>")+6
						);
						var svgBlob = new Blob([SVGCode], {type:"image/svg+xml;charset=utf-8"});
						var svgUrl = URL.createObjectURL(svgBlob);
						var downloadLink = document.createElement("a");
						downloadLink.href = svgUrl;
						do {
							var fileName = prompt("SVG File Name", "enter here");
							if (fileName.indexOf('.svg') == -1) {
								fileName = fileName + '.svg';
							}
						} while (fileName.length > 255 || fileName.length <= 0);
						downloadLink.download = fileName;
						document.body.appendChild(downloadLink);
						downloadLink.click();
						document.body.removeChild(downloadLink);
						overlayInput.checked = true;
						toggleOverlay(editor);



					//new mxXmlRequest(editor.urlEcho, 'filename=' + name + '&format=svg' + '&xml=' + xml).simulate(document, "_blank");
				};

				editor.addAction('exportSvg', exportSvg);

				buttons.push('exportImage');
				buttons.push('exportSvg');
			};


			for (var i = 0; i < buttons.length; i++)
			{
				var button = document.createElement('button');
				mxUtils.write(button, mxResources.get(buttons[i]));

				var factory = function(name)
				{
					return function()
					{
						editor.execute(name);
					};
				};

				mxEvent.addListener(button, 'click', factory(buttons[i]));
				node.appendChild(button);
			}

			// Create select actions in page
			var node = document.getElementById('zoomActions');
			mxUtils.write(node, 'Zoom ');
			mxUtils.linkAction(node, 'In', editor, 'zoomIn');
			mxUtils.write(node, ', ');
			mxUtils.linkAction(node, 'Out', editor, 'zoomOut');
			mxUtils.write(node, ', ');
			mxUtils.linkAction(node, 'Actual', editor, 'actualSize');
			mxUtils.write(node, ', ');
			mxUtils.linkAction(node, 'Fit', editor, 'fit');

			var variables = new Array();

			// add new container toolbar button action
			editor.addAction('addNewContainer', function(editor, cell){
				//editor.graph.setCellsSelectable(false);
				//editor.graph.setCellsMovable(false);
				var label = prompt("Syntax Unit Name", "name");
				if (label != null) {
					var i = 0;
					variables.push(label);
				  label = label + ":";
					var parent = editor.graph.getDefaultParent();
					var cellList = editor.graph.model.getChildCount(parent);
					// checking if containers already exist within the graph
					if (cellList > 0) {
						var containerList = editor.graph.getChildCells(parent);
						var lowestY = 0
						// searching for the lowest container
						for (i = 0; i < containerList.length; i++) {
							if (containerList[i].style == 'swimlane') {
								var contGeoComp = containerList[i].getGeometry();
								if (contGeoComp.y + contGeoComp.height >= lowestY) {
									lowestY = contGeoComp.y + contGeoComp.height;
								}
							}
						}
						// setting the y coordinate to the lowest found
						var y = lowestY;
					} else {
						var y = 0;
					}
					var x = 0;
					var index = cellList + 1;

					// refreshing the existing elements if we add a new non-terminal
					var coincd1 = 0
					var containerList = editor.graph.getChildCells(parent);
					for (i = 0; i < containerList.length; i++) {
						if (containerList[i].style == 'swimlane') {
							var containerChildren = editor.graph.model.getChildren(containerList[i]);
							for (z = 0; z < containerChildren.length; z++) {
								var cellType = containerChildren[z].getValue();
								if (cellType.tagName == 'Roundrect') {
									for (t = 0; t < variables.length; t++) {
										var tempLabel = containerChildren[z].getAttribute('label');
										if (tempLabel.localeCompare(variables[t]) == 0)
										{
											coincd1++;
										}
									}
									if (coincd1 > 0) {
										editor.graph.model.setStyle(containerChildren[z], 'Rect')
									}
								}
							}
						}
					}


					// adding a container

					var template = editor.templates['container'];
					var clone = editor.graph.model.cloneCell(template);
					var cloneGeo = clone.getGeometry();
					cloneGeo.y = y;
					cloneGeo.height = 100;
					editor.graph.model.setGeometry(clone, cloneGeo);
					clone.setAttribute('label', label);
					var newContainer = editor.graph.model.add(parent, clone, index);
					editor.graph.scrollCellToVisible(newContainer);

					// adding ellipses

					template = editor.templates['shape'];
					var clone = editor.graph.model.cloneCell(template);
					index++;
					var firstEllipse = editor.graph.model.add(newContainer, clone, index);
					var clone = editor.graph.model.cloneCell(template);
					index++;
					var secondEllipse = editor.graph.model.add(newContainer, clone, index);
					var containerGeo = editor.graph.getCellGeometry(newContainer).clone();
					var firstEllipseGeo = editor.graph.getCellGeometry(firstEllipse).clone();
					var secondEllipseGeo = editor.graph.getCellGeometry(secondEllipse).clone();
					firstEllipseGeo.y = firstEllipseGeo.y + 55;
					secondEllipseGeo.y = secondEllipseGeo.y + 55;
					secondEllipseGeo.x = secondEllipseGeo.x + containerGeo.width*0.9;
					editor.graph.model.setGeometry(firstEllipse, firstEllipseGeo);
					editor.graph.model.setGeometry(secondEllipse, secondEllipseGeo);

					// connecting ellipses

					var edgeTemplate = editor.templates['connector'];
					var edgeClone = editor.graph.model.cloneCell(edgeTemplate);
					var ellipseEdge = editor.graph.addEdge(edgeClone, newContainer, firstEllipse, secondEllipse);

					// adding overlay for vertical expansion

					var vert = editor.graph.insertVertex(newContainer, null, '', (cloneGeo.width/2-25), firstEllipseGeo.y+25, 35, 35, 'image;image=images/add.png;editable=0;movable=0;selectable=0;resizable=0');


					// disabling/enabling the visibility of the control depending on the checkbox

					if (overlayInput.checked) {
						vert.visible = true;
					} else {
						vert.visible = false;
					}


					var clickedOn = new Array();
					var wnd = null;
					// add vertical elements cell overlay event
					editor.graph.addMouseListener(
			 		{
					 currentState: null,
					 mouseDown: function(sender, me)
					 {
						 if (this.currentState != null)
						 {
							 this.dragLeave(me.getEvent(), this.currentState)
						 }
						 if (editor.graph.model.isVertex(me.getCell()))
						 {
							 	var cellPointer = me.getCell();
								var cellPointerGeo = editor.graph.getCellGeometry(cellPointer).clone();
								var containerGeo = editor.graph.getCellGeometry(newContainer).clone();
								if (cellPointer.style == 'image;image=images/add.png;editable=0;movable=0;selectable=0;resizable=0' && cellPointer.parent == newContainer)
								{
									// click on the add vertical elements overlay, draw red dot points between cells
									var cells = editor.graph.getChildCells(newContainer);
									// var size = 0
									var labels = []
									var cellz = []
									var dots = []
									console.log(cells);
									// go through cells and add red dot cell to the right of each cell
									for (var i=0; i < cells.length; i++)
									{
										if (cells[i].value.tagName == 'Rect' || cells[i].value.tagName == 'Roundrect')
										{
											var vertO = editor.graph.insertVertex(newContainer, null, '', (cells[i].geometry.x+cells[i].geometry.width+30), cells[i].geometry.y, 20, 20, 'image;image=images/symbols/event_end.png;editable=0;movable=0;selectable=0;resizable=0');
											dots.unshift(vertO);
											cellz.unshift(cells[i]);
										}
									}
									// go through cells again and add red dot cells to the left of leftmost cells
									for (var i=0; i < cellz.length; i++)
									{
										if (isLeftmost(cellz, i))
										{
											var vertO = editor.graph.insertVertex(newContainer, null, '', (cellz[i].geometry.x-30), cellz[i].geometry.y, 20, 20, 'image;image=images/symbols/event_end.png;editable=0;movable=0;selectable=0;resizable=0');
											dots.unshift(vertO);
										}
									}

									console.log('labels = ', labels);
									var htmlList = ''
									var html = ''
									if (labels.length > 0)
									{
										html = `<button id='submitBtn' style='align:right'>Select</button> <button id='closeBtn' style='align:right'>Cancel</button>`
									} else
									{
										html = `<span> No nodes in the graph <span> <br> <button id='closeBtn' style='align:right'>Close</button> `
									}
									var tb = document.createElement('div');
									tb.innerHTML = html;
									wnd = new mxWindow('Connection Select', tb, (document.getElementById('graph').getBoundingClientRect().left + containerGeo.width + 25), document.getElementById('graph').getBoundingClientRect().top, 300 , 200, false, true);
									wnd.setLocation = function(x, y)
									{
									  x = Math.max(0, x);
									  y = Math.max(0, y);
									  mxWindow.prototype.setLocation.apply(this, arguments);
									};

									// on "cancel" press go through the cells and delete the dots
									document.getElementById('closeBtn').onclick = function()
									{
										for (var i=0; i < dots.length; i++)
										{
											editor.graph.model.remove(dots[i]);
										}
										wnd.destroy();
									};
									if (labels.length > 0)
									{
										document.getElementById('submitBtn').onclick = function()
										{
											var lsIndex = 0;
											var rsIndex = 0;
											wnd.destroy();
										};
									}
									wnd.setVisible(true);
								}

								if (cellPointer.style == 'image;image=images/symbols/event_end.png;editable=0;movable=0;selectable=0;resizable=0' && cellPointer.parent == newContainer)
								{

									// add the cell coordinates to the clickedOn array
									if (clickedOn.length < 4)
									{
										clickedOn.push(cellPointerGeo.x);
										clickedOn.push(cellPointerGeo.y+10);
									}

									// go through the cells and remove the dot cells that are not on the same Y level if the start point is chosen
									var cells = editor.graph.getChildCells(newContainer);
									if (clickedOn.length == 2)
									{
										for (var i=0; i < cells.length; i++)
										{
											if (cells[i].style == 'image;image=images/symbols/event_end.png;editable=0;movable=0;selectable=0;resizable=0' && cellPointerGeo.y != cells[i].geometry.y)
											{
												editor.graph.model.remove(cells[i]);
											}
										}
									}

									// if the end point is chosen remove all dots and add the lines
									if (clickedOn.length == 4)
									{
										for (var i=0; i < cells.length; i++)
										{
											if (cells[i].style == 'image;image=images/symbols/event_end.png;editable=0;movable=0;selectable=0;resizable=0')
											{
												editor.graph.model.remove(cells[i]);
											}
										}
										// add the lines Here
										var bottomY = firstEllipse.geometry.y + firstEllipse.geometry.height/2 + 30;
										// find the lowest Y in the specified X range
										var containerChildren = editor.graph.model.getChildren(newContainer);
										for (i = 0; i < containerChildren.length; i++)
										{
											var cellType = containerChildren[i].getValue();
											if (cellType.tagName == 'Connector')
											{
													var childEdges = editor.graph.getChildEdges(containerChildren[i]);
													if (childEdges != undefined)
													{
														for (var j = 0; j < childEdges.length; j++)
														{
															if (childEdges[j].geometry.sourcePoint.y == childEdges[j].geometry.targetPoint.y && childEdges[j].geometry.targetPoint.y >= bottomY)
															{
																	if (childEdges[j].geometry.sourcePoint.x >= clickedOn[0] && childEdges[j].geometry.targetPoint.x <= clickedOn[2])
																	{
																		bottomY = childEdges[j].geometry.targetPoint.y;
																	} else if (childEdges[j].geometry.targetPoint.x >= clickedOn[0] && childEdges[j].geometry.sourcePoint.x <= clickedOn[2]) {
																		bottomY = childEdges[j].geometry.targetPoint.y;
																	}
															}
														}
													}
											}
										}
										var setY = bottomY + 30;

										// left line
										var cellE = new mxCell('edge', new mxGeometry(0, 0, 50, 50), 'curved=1;endArrow=classic;html=1;');
										cellE.geometry.setTerminalPoint(new mxPoint(clickedOn[0], clickedOn[1]), true);
										cellE.geometry.setTerminalPoint(new mxPoint(clickedOn[0]+30, setY), false);
										cellE.edge = true;
										cellE = editor.graph.addCell(cellE, ellipseEdge);
										editor.graph.fireEvent(new mxEventObject('cellsInserted', 'cells', [cellE]));

										// right line
										var cellE2 = new mxCell('edge', new mxGeometry(0, 0, 50, 50), 'curved=1;endArrow=classic;html=1;');
										cellE2.geometry.setTerminalPoint(new mxPoint(clickedOn[2]-30, setY), true);
										cellE2.geometry.setTerminalPoint(new mxPoint(clickedOn[2], clickedOn[3]), false);
										cellE2.edge = true;
										cellE2 = editor.graph.addCell(cellE2, ellipseEdge);
										editor.graph.fireEvent(new mxEventObject('cellsInserted', 'cells', [cellE2]));

										// middle flat line
										var cellE3 = new mxCell('edge', new mxGeometry(0, 0, 50, 50), 'curved=1;endArrow=classic;html=1;');
										cellE3.geometry.setTerminalPoint(new mxPoint(clickedOn[0]+30, setY), true);
										cellE3.geometry.setTerminalPoint(new mxPoint(clickedOn[2]-30, setY), false);
										cellE3.edge = true;
										cellE3 = editor.graph.addCell(cellE3, ellipseEdge);
										editor.graph.fireEvent(new mxEventObject('cellsInserted', 'cells', [cellE3]));

										// move the overlay itself
										var vertGeo = vert.geometry;
										vertGeo.y = bottomY + 50;
										editor.graph.model.setGeometry(vert, vertGeo);

										// resizing the container
										var containerGeo = editor.graph.getCellGeometry(newContainer).clone();
										containerGeo.height = vertGeo.y + vertGeo.height;
										editor.graph.model.setGeometry(newContainer, containerGeo);
										// variables to use later to determine where to place new cells
										var cellE3G = cellE3.geometry;
										var cellEG = cellE.geometry;
										var cellE2G = cellE2.geometry;

										// adding overlay to add elements to the line
										if (overlayInput.checked) {
											var overlayV = new mxCellOverlay(new mxImage('images/add.png', 28, 28), 'Add New Element');
										} else {
											var overlayV = new mxCellOverlay(new mxImage('images/add.png', 0, 0), 'Add New Element');
										}
										overlayV.cursor = 'hand';
										overlayV.offset.x = (clickedOn[2]-clickedOn[0] - 60)/2
										editor.graph.addCellOverlay(cellE3, overlayV);

										// overlay click action
										overlayV.addListener(mxEvent.CLICK, function(sender, evt2)
										{
											editor.graph.clearSelection();
											var labelNewStringV = prompt("New Element Name", "Enter here");
											var coincd = 0;
											if (labelNewStringV != null) {
												for (i = 0; i < variables.length; i++) {
													if (labelNewStringV.localeCompare(variables[i]) == 0)
													{
														coincd++;
													}
												}
												if (coincd > 0) {
													var stringTemplate = editor.templates['rectangle'];
												} else {
													var stringTemplate = editor.templates['rounded'];
												}
												var stringClone = editor.graph.model.cloneCell(stringTemplate);
												stringClone.setAttribute('label', labelNewStringV);
												// getting text width and resizing the rectangle if needed
												var contGeo = stringClone.getGeometry();
												contGeo.width = Math.round(getTextWidth(labelNewStringV, '11px arial')) + 30;
												editor.graph.model.setGeometry(stringClone, contGeo);

												// searching for far right cell x coordinate
												var elemLine = new Array();
												var containerChildren = editor.graph.model.getChildren(newContainer);
												console.log(containerChildren);
												var farRightX = cellEG.targetPoint.x;
												for (i = 0; i < containerChildren.length; i++)
												{
													var cellType = containerChildren[i].getValue();
													if (cellType.tagName == 'Rect' || cellType.tagName == 'Roundrect')
													{
														var geoCompare = containerChildren[i].getGeometry();
														if (geoCompare.x >= cellEG.targetPoint.x && geoCompare.y == (cellE3G.sourcePoint.y-10) && geoCompare.x <= cellE2G.sourcePoint.x)
														{
																if ((geoCompare.x + geoCompare.width) >= farRightX)
																{
																	farRightX = geoCompare.x + geoCompare.width;
																	var geoCompareF = geoCompare;
																}
																elemLine.push(containerChildren[i]);
														}
													}
												}

												// adding the cell and moving it
												var stringRectangle = editor.graph.model.add(newContainer, stringClone, index);
												var stringRectangleGeo = editor.graph.getCellGeometry(stringRectangle).clone();
												stringRectangleGeo.height = 20;
												stringRectangleGeo.y = cellE3G.sourcePoint.y-10;
												if (typeof geoCompareF != "undefined") {
													// if there are cells on this Y level add up widths of the elements
													var lengthSum = 10;
													for (i=0; i < elemLine.length; i++)
													{
														lengthSum += elemLine[i].getGeometry().width + 40;
													}
													lengthSum += stringRectangleGeo.width;
													// compare it to to the width of the line
													if (lengthSum > Math.abs(cellE3G.targetPoint.x - cellE3G.sourcePoint.x))
													{
														// have to extend the line and the parent line, possibly  adjust the other lines as well
														for (i=0; i<containerChildren.length; i++)
														{
															// if rectangle and to the right move further to the right
															var cellType = containerChildren[i].getValue();
															if (cellType.tagName == 'Rect' || cellType.tagName == 'Roundrect')
															{
																if (containerChildren[i].geometry.x >= cellE3G.targetPoint.x)
																{
																	var currCellGeo = containerChildren[i].geometry;
																	currCellGeo.x += stringRectangleGeo.width+40;
																	editor.graph.model.setGeometry(containerChildren[i], currCellGeo);
																}
															}
														}
														for (i=0; i<containerChildren.length; i++)
														{
															// if ellipse move to the right
															var cellStyle = containerChildren[i].getStyle();
															if (cellStyle == 'ellipse')
															{
																if (containerChildren[i].geometry.x > cellE3G.targetPoint.x)
																{
																	var currCellGeo = containerChildren[i].geometry;
																	currCellGeo.x += stringRectangleGeo.width+40;
																	editor.graph.model.setGeometry(containerChildren[i], currCellGeo);
																}
															}
															// moving the edge(s) to the right
															var cellType = containerChildren[i].getValue();
															if (cellType.tagName == 'Connector')
															{
																	var childEdges = editor.graph.getChildEdges(containerChildren[i]);
																	for (var j = 0; j < childEdges.length; j++)
																	{
																		if (childEdges[j].geometry.sourcePoint.x >= cellE3G.targetPoint.x)
																		{
																			var cEdgesGeo = childEdges[j].geometry;
																			cEdgesGeo.sourcePoint.x += stringRectangleGeo.width+40;
																			editor.graph.model.setGeometry(childEdges[j], cEdgesGeo);
																		}
																		if (childEdges[j].geometry.targetPoint.x >= cellE3G.targetPoint.x) {
																			var cEdgesGeo = childEdges[j].geometry;
																			cEdgesGeo.targetPoint.x += stringRectangleGeo.width+40;
																			editor.graph.model.setGeometry(childEdges[j], cEdgesGeo);
																			if (editor.graph.getCellOverlays(childEdges[j]) != null)
																			{
																				var cOverlay = editor.graph.getCellOverlays(childEdges[j])[0];
																				cOverlay.image = new mxImage('images/add.png', 28, 28);
																				cOverlay.offset.x = Math.abs((cEdgesGeo.targetPoint.x - cEdgesGeo.sourcePoint.x) / 2);
																			}
																		}
																	}
															}
														}
														stringRectangleGeo.x = farRightX + 40;
													} else {
														// dont have to extend the line, just add to the right
														stringRectangleGeo.x = farRightX + 40;
													}
												} else {
													// if there are no cells on this Y level put the cell on the leftmost point
													// stringRectangleGeo.x = (cellE2G.sourcePoint.x - cellEG.sourcePoint.x) / 2 + cellEG.sourcePoint.x - stringRectangleGeo.width/2;
													if (cellE3G.targetPoint.x > cellE3G.sourcePoint.x)
													{
														stringRectangleGeo.x = cellE3G.sourcePoint.x + 10;
													} else {
														stringRectangleGeo.x = cellE3G.targetPoint.x + 10;
													}
												}
												editor.graph.model.setGeometry(stringRectangle, stringRectangleGeo);
												// resizing container to the right (using the far right coordinate + offset) and moving the right ellipse  + overlay
												var farRightX1 = 0
												var containerChildren = editor.graph.model.getChildren(newContainer);
												for (i = 0; i < containerChildren.length; i++)
												{
													var geoCompare1 = containerChildren[i].getGeometry();
													if (geoCompare1.x > farRightX1)
													{
														farRightX1 = geoCompare1.x + geoCompare1.width;
													}
												}
												var containerGeo = newContainer.getGeometry();
												containerGeo.width = farRightX1;
												editor.graph.model.setGeometry(newContainer, containerGeo);
												// moving the add level overlay to container/2
												for (i = 0; i < containerChildren.length; i++)
												{
													var cellStyle = containerChildren[i].getStyle();
													if (cellStyle == 'image;image=images/add.png;editable=0;movable=0;selectable=0;resizable=0')
													{
														var vertGeo = containerChildren[i].getGeometry();
														vertGeo.x = vertGeo.x = Math.round(containerGeo.width / 2) - vertGeo.width/2;
														editor.graph.model.setGeometry(containerChildren[i], vertGeo);
														break;
													}
												}
												editor.graph.refresh();
											}
										});
										clickedOn.length = 0;
									}
								}
						 }
					 },
					 mouseMove: function(sender, me)
					 {},
					 mouseUp: function(sender, me)
					 {},
					 dragEnter: function(evt, state)
					 {},
					 dragLeave: function(evt, state)
					 {}
				 });

					// adding overlays - add button

					if (overlayInput.checked) {
						var overlay = new mxCellOverlay(new mxImage('images/add.png', 28, 28), 'Add New Element');
					} else {
						var overlay = new mxCellOverlay(new mxImage('images/add.png', 0, 0), 'Add New Element');
					}
					overlay.cursor = 'hand';
					editor.graph.addCellOverlay(ellipseEdge, overlay);

					// add new element overlay click event

					overlay.addListener(mxEvent.CLICK, function(sender, evt2)
					{
						editor.graph.clearSelection();
						var labelNewString = prompt("New Element Name", "Enter here");
						var coincd = 0;
						if (labelNewString != null) {
							for (i = 0; i < variables.length; i++) {
								if (labelNewString.localeCompare(variables[i]) == 0)
								{
									coincd++;
								}
							}
							if (coincd > 0) {
								var stringTemplate = editor.templates['rectangle'];
							} else {
								var stringTemplate = editor.templates['rounded'];
							}
							var stringClone = editor.graph.model.cloneCell(stringTemplate);
							stringClone.setAttribute('label', labelNewString);
							// getting text width and resizing the rectangle if needed
							var contGeo = stringClone.getGeometry();
							contGeo.width = Math.round(getTextWidth(labelNewString, '11px arial')) + 30;
							editor.graph.model.setGeometry(stringClone, contGeo);

							// searching for far right cell x coordinate
							var containerChildren = editor.graph.model.getChildren(newContainer);
							var farRightX = 0;
							for (i = 0; i < containerChildren.length; i++) {
								var cellType = containerChildren[i].getValue();
								if (cellType.tagName == 'Rect' || cellType.tagName == 'Roundrect') {
									var geoCompare = containerChildren[i].getGeometry();
									// console.log('geoCompare.x = ', geoCompare.x);
										if (geoCompare.x > farRightX && geoCompare.y == secondEllipseGeo.y-6) {
											farRightX = geoCompare.x + geoCompare.width/2;
											var geoCompareF = geoCompare;
										}
								}
							}
							// searching for far right edge point
							for (i = 0; i < containerChildren.length; i++)
							{
								var cellType = containerChildren[i].getValue();
								if (cellType.tagName == 'Connector')
								{
									var childEdges = editor.graph.getChildEdges(containerChildren[i]);
									for (var j = 0; j < childEdges.length; j++)
									{
										if (childEdges[j].geometry.sourcePoint.x > farRightX)
										{
											farRightX = childEdges[j].geometry.sourcePoint.x;
										}
										if (childEdges[j].geometry.targetPoint.x > farRightX)
										{
											farRightX = childEdges[j].geometry.targetPoint.x;
										}
									}
									break;
								}
							}

							// adding the cell and moving it
							var stringRectangle = editor.graph.model.add(newContainer, stringClone, index);
							var stringRectangleGeo = editor.graph.getCellGeometry(stringRectangle).clone();
							stringRectangleGeo.height = 20;
							// console.log('width, = ', stringRectangleGeo.width);
							stringRectangleGeo.y = secondEllipseGeo.y-6;
							if (typeof geoCompare != "undefined"){
								//stringRectangleGeo.x = farRightX + geoCompareF.width;
								stringRectangleGeo.x = farRightX + geoCompareF.width;
							} else {
								stringRectangleGeo.x = (((secondEllipseGeo.x - firstEllipseGeo.x) / 2) - (stringRectangleGeo.width / 2) + farRightX);
							}
							editor.graph.model.setGeometry(stringRectangle, stringRectangleGeo);

							// resizing container to the right (using the far right coordinate + offset) and moving the right ellipse  + overlay
							var farRightX1 = 0
							var containerChildren1 = editor.graph.model.getChildren(newContainer);
							for (i = 0; i < containerChildren1.length; i++) {
								var cellType1 = containerChildren1[i].getValue();
								var geoCompare1 = containerChildren[i].getGeometry();
										if (geoCompare1.x > farRightX) {
											farRightX1 = geoCompare1.x + geoCompare1.width;
										}
							}
							var containerGeo = editor.graph.getCellGeometry(newContainer).clone();
							containerGeo.width = farRightX1 + 55;
							secondEllipseGeo.x = containerGeo.width-10;
							editor.graph.model.setGeometry(secondEllipse, secondEllipseGeo);
							editor.graph.model.setGeometry(newContainer, containerGeo);

							// moving the vertical expansion overlay to container/2
							var vertGeo = editor.graph.getCellGeometry(vert).clone();
							vertGeo.x = Math.round(containerGeo.width / 2) - vertGeo.width/2;
							editor.graph.model.setGeometry(vert, vertGeo);
						}

					});

					overlay.getBounds = function(state)
					{
					  var bounds = mxCellOverlay.prototype.getBounds.apply(this, arguments);

					  if (state.view.graph.getModel().isEdge(state.cell))
					  {
					    var pt = state.view.getPoint(state, {x: 1, y: 0, relative: true});
					    bounds.x = pt.x - bounds.width / 2;
					    bounds.y = pt.y - bounds.height / 2;
					  }

					  return bounds;
					};

					// measuring the text width
					function getTextWidth(text, font)
					{
	    			var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
				    var context = canvas.getContext("2d");
				    context.font = font;
				    var metrics = context.measureText(text);
				    return metrics.width;
					}

					function isRightmost(list, index)
					{
						var right = new Array();
						for (var i=0; i < list.length; i++)
						{
							if (list[i].geometry.x > list[index].geometry.x && list[i].geometry.y == list[index].geometry.y)
							{
								right.push(list[i]);
							}
						}
						if (right.length == 0)
						{
							return true
						} else {
							return false
						}
					}

					function isLeftmost(list, index)
					{
						var left = new Array();
						for (var i=0; i < list.length; i++)
						{
							if (list[i].geometry.x < list[index].geometry.x && list[i].geometry.y == list[index].geometry.y)
							{
								left.push(list[i]);
							}
						}
						if (left.length == 0)
						{
							return true
						} else {
							return false
						}
					}
					// @todo:
					// re-align non-terminals
					// !!!DONE!!! add overlay toggle
					// refactor connections - consintent distances between cells, add arrows
					// !!!DONE!!! add vertical elements editing
					// !!!DONE!!! image saving
					// !!!DONE!!! xml saving
					// redo gui
					// !!!DONE!!! rectangle width based on text width
					// add overlay to xml saving
					// implement local storage
					// file ierarchy and dependencies cleanup
					editor.graph.refresh();
			}
		})
	}


		//window.onbeforeunload = function() { return mxResources.get('changesLost'); };
	</script>
</head>
<body onload="createEditor('config/diagrameditor.xml');">
	<div id="page">
		<div id="mainActions"
			style="width:100%;padding-top:8px;padding-left:24px;padding-bottom:8px;">
		</div>
		<div id="selectActions" style="width:100%;padding-left:54px;padding-bottom:4px;">
		</div>
		<table border="0" width="730px">
			<tr>
				<td id="toolbar" style="width:16px;padding-left:20px;" valign="top">
					<!-- Toolbar Here -->
				</td>
				<td valign="top" style="border-width:1px;border-style:solid;border-color:black;">
					<div id="graph" tabindex="-1" style="position:relative;height:480px;width:684px;overflow:hidden;cursor:default;">
						<!-- Graph Here -->
						<center id="splash" style="padding-top:230px;">
							<img src="images/loading.gif">
						</center>
					</div>
					<textarea id="xml" style="height:480px;width:684px;display:none;border-style:none;"></textarea>
				</td>
			</tr>
		</table>
		<span style="float:right;padding-right:36px;">
			<input id="source" type="checkbox"/>Source
		</span>
		<span style="float:right;padding-right:12px;">
			<input id="overlayToggle" type="checkbox"/>Controls
		</span>
		<div id="zoomActions" style="width:100%;padding-left:54px;padding-top:4px;">
		</div>
		<div id="footer">
			<br/>
		</div>
	</div>
</body>
</html>
